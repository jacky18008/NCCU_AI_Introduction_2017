執行方式：
	建立了一新的類別SearchNode來放置所需要的變數，並以內建的Stack/Queue形式來儲存。
	演算法大致是這樣的：
	
		建立初始的Node => 放進Stack/Queue
		
		（當Stack不為空，重複進行下面動作）：
		
		pop一個Node，檢查是否為Goal：
		
		是Goal: return該Node儲存的path（終止條件）
 		
		不是Goal:如果該Node未曾拜訪過，則把與該Node相鄰的Node全部放進Stack/		Queue裡面。

	其中，Stack搭配DFS，Queue搭配BFS。

實作心得：
	基本上是簡單的演算法，主要的麻煩的點在於要去讀懂題目提供的原始Code，並活用所提供的函	數，裡面使用了相當的虛擬類別，函數的呼叫是要注意的部分。
		
	此外，對python的資料結構也需要有足夠的認識，才能夠以相對簡明的方式完成。
	
	令人讚嘆的是，Berkeley的原始碼具有極高的可讀性。抽象化的層次非常高，也把複雜的執行面	好好地隱藏好了，讓學生只需要簡單地呼叫函式，就可以完成好像很厲害的結果。Demo的方式也非	常清楚易懂、易於操作，是值得我們學習的地方。


疑難雜症處理：
	其實跟Python並不是非常熟，一般主要是用來進行套件操作而已，對於一些類別的建立與呼叫偶爾	會有一些疑問的地方，幸好之後Google之後都能解決。至於原始碼的理解，則是參考了網路上一些	人的解釋，還有官方網站上的說明。 

			
				      